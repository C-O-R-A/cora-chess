import os
import cv2
import vision_helpers as vh
import numpy as np

def get_board_size(im, markers: dict) -> float:
    '''
    Get the size of the board in real space
    
    :param im: Image array
    :param markers: Marker dict with poses for each marker corner
    :type markers: dict
    :return: Real size of the board (length)
    :rtype: float
    '''

    # Actual marker width
    marker_width = np.linalg.norm(markers['marker_0'][0][1] - markers['marker_0'][0][0])

    # Board and marker pixel width
    persp = vh.perspective_correction(im=im)
    board_px, square_px = vh.board_size_from_checkers(persp)

    # Actual board size
    board_size = board_px * (marker_width / square_px)

    return board_size

def detect_move(im1, im2, verbose=False, show=False, plot=False, folder=False) -> str:
    """
    detects move by comparing two images of the board,
    before and after the opponent's move.
    Returns the move in UCI format.
    This method picks up on changes to squares based on highlights
    and shadows generated by the pieces
    being on squares, and the changes
    in those highlights and shadows when pieces move.

    :param im1: Description
    :param im2: Description
    """
    # Greyscale the images to simplify comparison
    grey1 = cv2.cvtColor(im1, cv2.COLOR_BGR2GRAY)
    grey2 = cv2.cvtColor(im2, cv2.COLOR_BGR2GRAY)

    flat_im_1 = vh.perspective_correction(grey1, show=show)
    flat_im_2 = vh.perspective_correction(grey2, show=show)

    board_size, square_size = vh.board_size_from_checkers(flat_im_1)

    cropped_im_1 = vh.crop_img(flat_im_1, board_size)
    cropped_im_2 = vh.crop_img(flat_im_2, board_size)

    if show:
        cv2.imshow("Flat Image 1", cropped_im_1)
        cv2.imshow("Flat Image 2", cropped_im_2)

        cv2.waitKey(0)
        cv2.destroyAllWindows()

    square_dict_1, overlayed_im_1 = vh.noise_scores(cropped_im_1, square_size, verbose=verbose, plot=plot, folder=folder)
    square_dict_2, overlayed_im_2 = vh.noise_scores(cropped_im_2, square_size, verbose=verbose, plot=plot, folder=folder)

    if show:
        cv2.imshow("Overlayed image 1", overlayed_im_1)
        cv2.imshow("Overlayed image 2", overlayed_im_2)
        cv2.waitKey(0)
        cv2.destroyAllWindows()
    
    for (square, info_1), (square, info_2) in zip(square_dict_1.items(), square_dict_2.items()):
        if info_1["occupied"] and not info_2["occupied"]:
            now_empty = square
        elif not info_1["occupied"] and info_2["occupied"]:
            now_occluded = square

    move = f"{now_empty}{now_occluded}"

    if verbose:
        print(move)

    if folder:
        cv2.imwrite(os.path.join(folder, 'cropped_image_1.png'), cropped_im_1)
        cv2.imwrite(os.path.join(folder, 'cropped_image_2.png'), cropped_im_2)
        cv2.imwrite(os.path.join(folder, 'persp_correct_image_1.png'), flat_im_1)
        cv2.imwrite(os.path.join(folder, 'persp_correct_image_2.png'), flat_im_2)
        cv2.imwrite(os.path.join(folder, 'overlayed_image_1.png'), overlayed_im_1)
        cv2.imwrite(os.path.join(folder, 'overlayed_image_2.png'), overlayed_im_2)

    return move